---
layout: post
title: "[LeetCode][DP] #887. 让蛋飞一会儿"
date: 2020-05-22 17:22:00
tags:
  - LeetCode
categories:
  - Algorithm
---

> LeetDP 果然名不虚传 (Doge)

<!-- more -->

[887. Super Egg Drop](https://leetcode.com/problems/super-egg-drop/description/)

## 题目

给 $K$ 个蛋从有 $N$ 层的楼上扔下去，问最少扔多少次可以确定某层扔下去会碎。（魔幻硬度的蛋，蛋当然是可能在任意一层会碎）

首先可以参考李永乐老师的视频

[复工复产找工作？先来看看这道面试题：双蛋问题\_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://​www.bilibili.com/video/BV1KE41137PK)

这里的解法比较直观，讲的也比较详细，可以对这个问题有个完整的理解。这里直接给出转移方程，$f(k,n)$ 表示当有个 $k$ 鸡蛋和 $n$ 层楼时需要扔的最少次数：

$$
f(k,n)=min^{l=1}_{l \to n}\{max\{f(k,l),f(k-1,n-1)\}\}
$$

核心思路是在某一层扔下去，有两种可能，**碎或者不碎**，然后转换成对**剩余楼层和蛋的解**。**取最大值即可保证该次数一定能确定楼层**。最后对每个可以扔的楼层得到的答案**取最小得到最终答案**。但是这个解法是暴力的 $O(KN^2) ，LeetCode 讨论区有更好的解法，当然描述过于简洁，以至于低智商的人无法马上理解（指本文作者），这里进一步解释一下思路。

`...-/-.-./`

![第一层就会碎的ΩДΩ](images/2020/drop_egg.webp)

## 换个方向思考

本来我们是要通过楼层和蛋的数量作为状态的分割，但是分析可知，投掷蛋的次数最大不会超过蛋的数量或者楼层的数量，尤其是当蛋的数量比较多的时候。视频中可以看到，实际上用不是最优二分法，需要用到的蛋也只有 $log_2N$ 。在这个前提下，把投掷次数作为状态分割是可行的。

先给出状态转移方程：

$$
f(m,k)=f(m-1,k)+f(m-1,k-1)+1
$$

表示有 $k$ 个蛋扔 $m$ 次，可以确定哪层楼会碎的**总楼层数**。可以说相当不直观了。乍看下去好像根本没有**最少**或者**最优**的信息在里面，也不包含要在第几层扔这个信息。应当这样理解，正如前面所提到的，无论鸡蛋在哪一层扔，都必定转化为对两个更矮的楼的问题。先假设两个更矮楼层的解是已知的，无论这个矮楼有多少层，那也就是说必定能推出两个楼层加起来的楼层的解，也就是多扔一次鸡蛋（表现为 $m$ 增加）。当然扔鸡蛋的这一层扔过了，无论是不是这层就是会碎的最低那层，这层都已经被测试过了，也就是上式中最后的增加的那一层。

```swift
func superEggDrop(_ K: Int, _ N: Int) -> Int {
    var f: [Int] = Array(repeating: 0, count: K + 1)
    var m = 0
    while f.last! < N {
        for i in (1...K).reversed() {
            f[i] += f[i - 1] + 1
        }
        m += 1
    }

    return m
}
```

这里给出一维数组的代码，与二维数组是等效的。通过倒序求状态，即可在计算过程保留前一状态并覆盖不再用到的状态。因为扔的次数一定增加，所以与当前次数的解无关，且仅与上一次扔蛋有关，也就无须存储每次的状态。

注意边界条件，扔 0 次和有 0 个蛋都不能确定任何楼层。

## 不能确信？

因为这个思路不够直观，一个显然可知似乎并不是那么能让人确信。不过从初始状态开始推演，通过数学归纳法可以证明答案是正确的。不知是否有更好的证明方法，如果有大佬知道如何证明，请不吝赐教。

(,,・ω・,,)
